CREATE TABLE DEPT(
   DEPTNO NUMBER(2) CONSTRAINT pk_dept PRIMARY KEY,
   DNAME VARCHAR2(14),
   LOC VARCHAR2(13)
);

INSERT INTO DEPT VALUES (10,'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES (30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');


CREATE TABLE EMP(
   EMPNO NUMBER(4) CONSTRAINT pk_emp PRIMARY KEY,
   ENAME VARCHAR2(10),
   JOB VARCHAR2(9),
   MGR NUMBER(4), 
   HIREDATE DATE,
   SAL NUMBER(7,2),
   COMM NUMBER(7,2),
   DEPTNO NUMBER(2) 
);

INSERT INTO EMP VALUES (7839,'KING','PRESIDENT',null,TO_DATE('1981-11-17','yyyy-mm-dd'),5000,null,10);
INSERT INTO EMP VALUES (7566,'JONES','MANAGER',7839,TO_DATE('1981-04-02','yyyy-mm-dd'),2975,null,20);
INSERT INTO EMP VALUES (7698,'BLAKE','MANAGER',7839,TO_DATE('1981-05-01','yyyy-mm-dd'),2850,null,30);
INSERT INTO EMP VALUES (7782,'CLARK','MANAGER',7839,TO_DATE('1981-06-09','yyyy-mm-dd'),2450,null,10);
INSERT INTO EMP VALUES (7788,'SCOTT','ANALYST',7566,TO_DATE('1987-04-19','yyyy-mm-dd'),3000,null,20);
INSERT INTO EMP VALUES (7902,'FORD','ANALYST',7566,TO_DATE('1981-12-03','yyyy-mm-dd'),3000,null,20);
INSERT INTO EMP VALUES (7499,'ALLEN','SALESMAN',7698,TO_DATE('1981-02-20','yyyy-mm-dd'),1600,300,30);
INSERT INTO EMP VALUES (7521,'WARD','SALESMAN',7698,TO_DATE('1981-02-22','yyyy-mm-dd'),1250,500,30);
INSERT INTO EMP VALUES (7654,'MARTIN','SALESMAN',7698,TO_DATE('1981-09-28','yyyy-mm-dd'),1250,1400,30);
INSERT INTO EMP VALUES (7844,'TURNER','SALESMAN',7698,TO_DATE('1981-09-08','yyyy-mm-dd'),1500,null,30);
INSERT INTO EMP VALUES (7900,'JAMES','CLERK',7698,TO_DATE('1981-12-03','yyyy-mm-dd'),950,null,30);
INSERT INTO EMP VALUES (7934,'MILLER','CLERK',7782,TO_DATE('1982-01-23','yyyy-mm-dd'),1300,null,10);
INSERT INTO EMP VALUES (7369,'SMITH','CLERK',7902,TO_DATE('1980-12-17','yyyy-mm-dd'),800,null,20);
INSERT INTO EMP VALUES (7876,'ADAMS','CLERK',7788,TO_DATE('1987-05-23','yyyy-mm-dd'),1100,null,20);
COMMIT;

CREATE TABLE salgrade(
   grade number(7,2),
   losal number(7,2),
   hisal number(7,2)
);

INSERT INTO salgrade values(1,700,1200);
INSERT INTO salgrade values(2,1201,1400);
INSERT INTO salgrade values(3,1401,2000);
INSERT INTO salgrade values(4,2001,3000);
INSERT INTO salgrade values(5,3001,9999);

create table student(
stu_no char(9),
stu_name varchar2(12),
stu_dept varchar2(20),
stu_grade number(1),
stu_class char(1),
stu_gender char(1),
stu_height number(5,2),
stu_weight number(5,2),
constraint p_stu_no primary key(stu_no));

insert into student values(20153075, '옥한빛','기계',1,'C','M',177,80);
insert into student values(20153088, '이태연','기계',1,'C','F',162,50);
insert into student values(20143054, '유가인','기계',2,'C','F',154,47);
insert into student values(20152088, '조민우','전기전자',1,'C','M',188,90);
insert into student values(20142021, '심수정','전기전자',2,'A','F',168,45);
insert into student values(20132003, '박희철','전기전자',3,'B','M',null,63);
insert into student values(20151062, '김인중','컴퓨터정보',1,'B','M',166,67);
insert into student values(20141007, '진현무','컴퓨터정보',2,'A','M',174,64);
insert into student values(20131001, '김종헌','컴퓨터정보',3,'C','M',null,72);
insert into student values(20131025, '옥성우','컴퓨터정보',3,'A','F',172,63);

create table subject(
sub_no char(3),
sub_name varchar2(30),
sub_prof varchar2(12),
sub_grade number(1),
sub_dept varchar2(20),
constraint p_sub_no primary key(sub_no));

insert into subject values('111', '데이터베이스','이재영',2,'컴퓨터정보');
insert into subject values('110', '자동제어','정순정',2,'전기전자');
insert into subject values('109', '자동화설계','박민영',3,'기계');
insert into subject values('101', '컴퓨터개론','강종영',3,'컴퓨터정보');
insert into subject values('102', '기계공작법','김태영',1,'기계');
insert into subject values('103', '기초전자실험','김유석',1,'전기전자');
insert into subject values('104', '시스템분석설계','강석현',3,'컴퓨터정보');
insert into subject values('105', '기계요소설계','김명성',1,'기계');
insert into subject values('106', '전자회로실험','최영민',3,'전기전자');
insert into subject values('107', 'CAD응용실습','구봉규',2,'기계');
insert into subject values('108', '소프트웨어공학','권민성',1,'컴퓨터정보');

create table enrol(
sub_no char(3),
stu_no char(9),
enr_grade number(3),
constraint p_course primary key(sub_no,stu_no));

insert into enrol values('101','20131001',80);
insert into enrol values('104','20131001',56);
insert into enrol values('106','20132003',72);
insert into enrol values('103','20152088',45);
insert into enrol values('101','20131025',65);
insert into enrol values('104','20131025',65);
insert into enrol values('108','20151062',81);
insert into enrol values('107','20143054',41);
insert into enrol values('102','20153075',66);
insert into enrol values('105','20153075',56);
insert into enrol values('102','20153088',61);
insert into enrol values('105','20153088',78);

select * from emp;

select empno, ename, job from emp where ename LIKE 'K%';
select * from emp where ename LIKE 'W%D';
select ename, job, deptno from emp where deptno = 10 and job != 'clerk';
이름중 'o'가 들어가는 사람의 모든 사원정보를 출력

select * from emp where ename like '%O%';

SELECT * FROM STUDENT;

[NULL] NULL값 찾기
SELECT * FROM STUDENT WHERE STU_HEIGHT is null;

[IN] 
select * from student where stu_grade = 1
or stu_grade = 2
or stu_grade = 3;

SELECT * FROM STUDENT
WHERE STU_GRADE IN (1,2,3);]

select * from emp;

10) manager, analyst, clerk인 사원들의 사원이름, 사원 월급, 사원번호를 보이시오.
select ename, sal, empno from emp where JOB IN ('MANAGER','ANALYST','CLERK');

11) 사원중에 comm 받고 salesman인 사원의  사원이름, 사원번호, 총급여(sal + comm)
select empno, ename, (sal + comm) as 총급여 from emp where comm is not null
and job = 'SALESMAN';

12) 부서번호가 10,20이 아닌 사원의 이름 부서번호를 출력
select ename, deptno from emp where deptno != 10
and deptno != 20;
select ename, deptno from emp where deptno not in(10,20);

13 ) 급여가 1000과 2000사이가 아닌 사원의 이름, 급여를 출력
select ename, sal from emp where sal not between 1000 and 2000; 

select ename, sal
from emp order by sal;

select ename, sal
from emp order by sal desc;

select ename as 이름, sal empno from emp order by 이름;

select * from emp;
14) 사원들의 사원직무별, 급여 순으로 검색하라.
    단, 급여는 1000만원 이상만 검색.
SELECT job, sal from emp where sal >= 1000 ORDER BY job, sal;

15) 부서번호가 30번인 사원들 중에 사원번호, 이름, 입사일을 출력하시오.
    단, 사원 번호를 오름차순으로 정렬하시오
SELECT empno, ename, hiredate from emp where deptno = 30 order by empno asc;

16 ) 매니저가 아닌 사원들 중에 comm을 받지 않는 사원들의 정보를 모두 출력하시오.
    단, 사원번호 순으로 정렬하시오
SELECT * FROM emp where job != 'MANAGER' and comm is null or comm = 0 order by empno;

[함수] DUAL - 빈껍데기 테이블
숫자형 
SELECT ABS(-10) FROM DUAL; //정수출력
SELECT ROUND(STU_HEIGHT,-1) FROM STUDENT; //반올림
SELECT SIGN(-10) FROM DUAL; //음수양수 판별
SELECT MOD(11, 2) FROM DUAL; //숫자 (A, B) A를 B로 나눈 나머지값 짝수 홀수 확인
SELECT FLOOR(10.6) FROM DUAL; //실수반환 = 버림
SELECT CEIL(10.3) FROM DUAL; //실수반환 = 올림
SELECT TRUNC(10.56, 1) FROM DUAL; // 소수2째자리 버림

[문자형]
SELECT LOWER('KOREA') FROM DUAL; // 소문자변환
SELECT UPPER('korea') FROM DUAL; // 대문자 변환
SELECT INITCAP('korea') FROM DUAL; //첫째글짜만 대문자 변환
SELECT CONCAT('Hello','World!') FROM DUAL; // CONCAT('A', 'B') A와 B를 연결
SELECT SUBSTR('ABCDEFG', 2,4) FROM DUAL; // SUBSTR('A', B,C) A의 문자열에서 B에서 C번째까지 출력

SELECT LPAD('ABC',5,'*') FROM DUAL;
SELECT RPAD('ABC',5,'*') FROM DUAL;

SELECT RPAD(SUBSTR('950826-1054868',0, 8),14,'*') FROM DUAL; //주민번호 별표처리

[날짜형]
SELECT SYSDATE FROM DUAL;
SELECT SYSDATE+9 /24 FROM DUAL;
SELECT ADD_MONTHS(SYSDATE, 1) FROM DUAL; // 월 증가
SELECT LAST_DAY(SYSDATE) FROM DUAL; // 현재의 마지막날
SELECT LAST_DAY(ADD_MONTHS(SYSDATE ,1)) FROM DUAL; // 다음월의 마지막날

SELECT ROUND(SYSDATE) FROM DUAL; // 올림
SELECT ROUND(SYSDATE, 'YEAR') FROM DUAL; // 연 반올림
SELECT ROUND(SYSDATE, 'MONTH') FROM DUAL; // 월 반올림
SELECT TRUNC(SYSDATE) FROM DUAL; // 버림

SELECT * FROM EMP;
17) 사원들의 사원이름, 사원직무를 소문자로 검색하시오. LOWER
SELECT LOWER(ENAME), LOWER(JOB) FROM EMP;

18) 사원들의 사원이름과 사원이름의 첫 글자를 검색하시오.
SELECT ENAME, SUBSTR(ENAME, 0, 1) FROM EMP;

19) 사원이름을 10자리로 하고 뒤로 '-'를 채워넣으시오
SELECT RPAD(ENAME, 10, '-') FROM EMP;

20) 사원번호, 입사일, 근무일자를 검색하여 출력하시오.
SELECT EMPNO, HIREDATE, ROUND((SYSDATE-HIREDATE)) AS 근무일자 FROM EMP;

<<<<<<<<<<<2020-05-28>>>>>>>>>>>
1) 사원번호, 입사일, 입사 10년째 날짜를 검색하시오.
SELECT EMPNO, HIREDATE, HIREDATE + (10*365) + 2 FROM EMP;
SELECT EMPNO, HIREDATE, ADDMONTHS(HIREDATE, 12, 10) FROM EMP;

2) 입사일이 81/04/02보다 늦고 82/12/09보다 빠른 사원의 이름 월급 부서번호를 출력하시오
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE BETWEEN HIREDATE '81/04/02 AND '/82/12/09'
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE HIREDATE > '81/04/02' AND HIREDATE < '/82/12/09'

[형변환]
TO_CHAR
TO_DATE
TO_NUMBER

SELECT TO_CHAR(123456789) FROM DUAL;
SELECT TO_CHAR(SYSDATE) FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'MM-DD-YYYY') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'MM/DD/YYYY') FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'MM-DD-YYYY, HH:MI:SS AM') FROM DUAL;
SELECT ENAME, TO_CHAR(HIREDATE, 'YY-MM-DD') FROM EMP;
SELECT TO_CHAR('123456789', '999,999,999') FROM DUAL;

SELECT TO_NUMBER('123456789') + 1 FROM DUAL;
SELECT '123456789' + 1 FROM DUAL; // 문자열은 원래 +-/* 불가 요즘은 자동형변환

SELECT TO_DATE('2020-05-28') FROM DUAL;
SELECT TO_DATE('05-28-2020', 'MM-DD-YYYY') FROM DUAL;

[NULL 활용]
NVL = NULL값을 더하기할때 NULL값을 우리가아는 숫자형태로 변환
NVL([열, 값], 0)
SELECT ENAME, COMM, NVL(COMM,0) + SAL AS 총급여 FROM EMP;

NVL2([열, 값], NOT NULL값, NULL값)
SELECT ENAME, NVL2(COMM, SAL+COMM, SAL) FROM EMP;

SELECT * FROM EMP;
문1) 모든 사원의 커미션을 200식 추가하시오. 사원이름, 월급, 
    커미션, 전체수입을 보이시오.
SELECT ENAME, SAL, NVL(COMM, 0) + 200 , SAL + NVL(COMM, 0) + 200 AS 총급여 FROM EMP;
SELECT ENAME 사원이름 , SAL 월급, NVL2(COMM, COMM+200, 200) AS 커미션, SAL+NVL2(COMM, COMM+200, 200) AS 전체수입 FROM EMP;

문2) MGR이 없는 사원의 경우 '사장님'으로 나타나도록 출력하시오
    사원이름, 상급자를 출력하시오.
SELECT ENAME, JOB FROM EMP WHERE JOB != 'MANAGER';
SELECT ENAME, NVL2(MGR, TO_CHAR(MGR), '사장님') FROM EMP;
SELECT ENAME, NVL(TO_CHAR(MGR), '사장님') FROM EMP;

[NULLIF]
NULLIF([값1], [값2] = NULL 출력
SELECT NULLIF('A', 'A') FROM DUAL; // 똑같으면 NULL출력
SELECT NULLIF('A', 'B') FROM DUAL; // 다르면 A출력

SELECT NVL(NULLIF('A', 'A'), '값이 동일합니다') FROM DUAL; //NVL과 같이씀 비교
SELECT STU_NAME, NVL2(NULLIF(TO_CHAR(STU_WEIGHT), '90'), '정보없음', '몸무게 90KG') FROM STUDENT;
SELECT COALESCE (NULL, NULL, 100, NULL) FROM DUAL; //맨처음부터비교해서 널값아닌것만 출력하고 끝.

SELECT USER FROM DUAL; // 현재 어떤유저가 데이터를 가지고오고 있는지
SELECT UID FROM DUAL; // 유저의 식별번호 출력

SELECT EMPNO, ENAME, JOB, SAL,
    CASE JOB WHEN 'SALESMAN' THEN SAL*1.1
        WHEN 'CLERK' THEN SAL*1.3
        WHEN 'MANAGER' THEN SAL*1.5
        ELSE SAL
    END AS 급여인상 
FROM EMP;
문3) 학생들 중에 기계과학생의 등록금 1000만원 
전기전자학생 등록금 500만원
컴퓨터정보학생 등록금 300만원
학번, 이름 전공, 등록금을 출력하는데 2013학번만 출력.
SELECT * FROM STUDENT;
SELECT STU_NO, STU_NAME, STU_DEPT,
    CASE STU_DEPT WHEN '기계' THEN '1000만원'
        WHEN '전기전자' THEN '500만원'
        WHEN '컴퓨터정보' THEN '300만원'
        ELSE '100만원'
    END AS 등록금
FROM STUDENT WHERE STU_NO LIKE ('2013%');

SELECT empno, ename, sal,
DECODE(job, 'SALESMAN', sal*1.1,
            'CLERK', sal*1.3,
            'MANAGER', sal*1.5,
            sal) as 인상된 급여
FROM EMP;

SELECT empno, ename, sal,
DECODE (job, 'SALESMAN', sal*1.1,
'CLERK', sal*1.3,
'MANAGER', sal*1.5,
sal) as 인상된 급여
FROM EMP;

SELECT STU_NO, STU_NAME, STU_DEPT,
    DECODE(STU_DEPT, '기계', '1000만원',
                    '전기전자', '500만원',
                    '컴퓨터정보', '300만원',
                    '2000만원') AS 등록금
FROM STUDENT
WHERE STU_NO LIKE ('2013%');

문4) 학생들의 키가 측정되어 있지 않을경우 '재검' 이라고 출력하고,
    키 데이터가 있으면 '필요없음'이라고 검사사항을출력하시오.
    출력 항목은 학생이름, 키, 검사사항 입니다.
SELECT STU_NAME, STU_HEIGHT, NVL2(TO_CHAR(STU_HEIGHT), '필요없음', '재검') FROM STUDENT
    
문5) 사원들의 사원이름, 사원직무를 연결하여 검색하시오
    (예: King President)
SELECT INITCAP(ENAME) || ' ' || INITCAP(JOB) FROM EMP;


문6) 사장님의 급여를 2배 인상하여 출력하시오 (decode)
    이름, 사원번호, 급여
SELECT ENAME, EMPNO, DECODE(JOB, 'PRESIDENT', SAL*2, SAL)
FROM EMP;

[MULTI-ROW FUNCTION] 집계함수
SELECT COUNT(*) FROM EMP;
SELECT COUNT(MGR) FROM EMP;
SELECT COUNT(EMPNO) FROM EMP;

SELECT SUM(SAL) FROM EMP;
SELECT AVG(SAL) FROM EMP;
SELECT MIN(SAL) FROM EMP;
SELECT MAX(SAL) FROM EMP;
SELECT STDDEV(SAL) FROM EMP; //분산
SELECT VARIANCE(SAL) FROM EMP; //표준편차

SELECT MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN'; //SALESMAN중 가장월급이 높은사람
(X) 안되는코드
SELECT ENAME, MAX(SAL) FROM EMP WHERE JOB = 'SALESMAN';

SELECT JOB, ROUND(AVG(SAL)) FROM EMP GROUP BY JOB; // JOB별 급여 평균

SELECT JOB, DEPTNO, ROUND(AVG(SAL)) FROM EMP GROUP BY JOB, DEPTNO; // JOB별 DEPT별 급여 평균

SELECT JOB, ROUND(AVG(SAL)) AS 평균급여 FROM EMP 
GROUP BY JOB
ORDER BY 평균급여

문7) SALESMAN의 커미션 평균을 출력하시오
SELECT AVG(COMM) FROM EMP WHERE JOB = 'SALESMAN';

문8) 직무별 최대 임금을 출력하시오
SELECT JOB, MAX(SAL) FROM EMP GROUP BY JOB;

문9) 직무별 평균 급여(SAL+COMM)을 추출력하시오
SELECT JOB, ROUND(AVG(SAL+NVL(COMM, 0))) FROM EMP GROUP BY JOB;

[HAVING]
SELECT JOB, ROUND(AVG(SAL))
FROM EMP GROUP BY JOB
HAVING AVG(SAL) > 2000;

SELECT STU_DEPT, ROUND(AVG(STU_HEIGHT))
FROM STUDENT
GROUP BY STU_DEPT
HAVING AVG(STU_HEIGHT) > 170;

문10) 직무별, 사원수를 출력하시오
    단, 직무별 인원이 3명이상인 직무만 출력하시오
SELECT JOB, COUNT(EMPNO) FROM EMP GROUP BY JOB HAVING COUNT(EMPNO) >= 3;

문11) 사원수가 4명이상인 부서의 부서번호와 사원수를 출력하시오
SELECT DEPTNO, COUNT(EMPNO) FROM EMP GROUP BY DEPTNO HAVING COUNT(EMPNO) >= 4;


문12) 부서번호, 부서별 평균임금을 출력하시오 단 평균임금이 2000이하인 부서는 제외
SELECT DEPTNO, ROUND(AVG(SAL)) FROM EMP GROUP BY DEPTNO HAVING AVG(SAL) > 2000;

문13) 부서별 직무별 사원들의 급여 편차가 적은 순으로 검색하시오
SELECT DEPTNO, JOB, ROUND(STDDEV(SAL)) FROM EMP
GROUP BY DEPTNO, JOB
HAVING COUNT(JOB) NOT IN (0,1)
ORDER BY DEPTNO;

[Inline view]
SELECT * FROM EMP;
SELECT * FROM (SELECT EMPNO, ENAME FROM EMP);
SELECT * FROM (SELECT AVG(STU_HEIGHT) AS AVG_HEIGHT FROM STUDENT) WHERE AVG_HEIGHT > 170;
SELECT STUNAME, MAX(STU_HEIGHT) FROM STUDENT;(X)

SELECT STU_NAME, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT = (SELECT MAX(STU_HEIGHT) FROM STUDENT);
(최대신장)
SELECT MAX(STU_HEIGHT) FROM STUDENT

문1) 직무별 사원 평균 급여, 분산, 표준편차를 검색하시오.
SELECT JOB ROUND(AVG(SAL)), ROUND(VARIANCE(SAL)), ROUND(STDDEV(SAL)) FROM EMP GROUP BY  JOB;
문2) 직무별, 부서별 사원의 급여 합이 많은 순으로 검색하시오.
SELECT JOB, DEPTNO, SUM(SAL + NVL(COMM, 0)) FROM EMP GROUP BY JOB, DEPTNO
문3) 직무 중 가장 적게 수입을 가지는 직무의 평균 월급을 출력하시오.(커미션 포함)
SELECT JOB, AVG(SAL + NVL(COMM, 0)) AS 평균월급 FROM EMP GROUP BY JOB HAVING SUM(SAL + NVL(COMM, 0)) = (SELECT MIN(SUM(SAL + NVL(COMM, 0))) FROM EMP GROUP BY JOB);
문4) 기계과 학생들 중 한년별 평균 신장이 160이상인 학년과 평균신장을 출력하시오.
SELECT STU_GRADE, ROUND(AVG(STU_HEIGHT)) FROM STUDENT WHERE STU_DEPT = '기계' GROUP BY STU_GRADE HAVING AVG(STU_HEIGHT) >= 160;
문5) 최대신장이 175이상인 학과와 학과별 최대신장을 출력하시오.
SELECT STU_DEPT, MAX(STU_HEIGHT) FROM STUDENT GROUP BY STU_DEPT HAVING MAX(STU_HEIGHT) >= 175;

1
DESC STUDENT;
2
DESC SUBJECT;
3
SELECT * FROM STUDENT;
4
SELECT * FROM ENROL;
5
SELECT STU_NO, STU_NAME FROM STUDENT;
6
SELECT SUB_NO, SUB_NAME FROM SUBJECT;
7
SELECT STU_NO, STU_NAME, STU_GENDER FROM STUDENT;
8
SELECT * FROM STUDENT;
9
SELECT STU_NO, STU_NAME, STU_GRADE, STU_CLASS FROM STUDENT;
10
SELECT SUB_NO, SUB_NAME, SUB_PROF FROM SUBJECT;
11
SELECT SUB_NO, STU_NO, ENR_GRADE FROM ENROL;
12
SELECT STU_WEIGHT, STU_HEIGHT, STU_NO, STU_NAME FROM STUDENT;
13
SELECT DISTINCT STU_DEPT FROM STUDENT;
14
SELECT DISTINCT STU_GENDER FROM STUDENT;
15
SELECT DISTINCT STU_GRADE FROM STUDENT;
16
SELECT DISTINCT STU_DEPT, STU_GRADE FROM STUDENT;
17
SELECT DISTINCT STU_DEPT, STU_CLASS FROM STUDENT;
18
SELECT STU_WEIGHT+5 FROM STUDENT;
19
SELECT STU_WEIGHT-5 FROM STUDENT;
20
SELECT STU_NO AS 학번, STU_NAME AS 이름 FROM STUDENT;
21
SELECT * FROM ENROL;
SELECT SUB_NO AS 번호, STU_NO AS 학번, ENR_GRADE 점수 FROM ENROL;
22 
SELECT * FROM SUBJECT;
SELECT SUB_NAME 과목이름, SUB_PROF 교수명 FROM SUBJECT;
23
SELECT STU_DEPT || ' ' || STU_NAME FROM STUDENT;

24
SELECT STU_DEPT || '과 ' || STU_NAME || '입니다' FROM STUDENT;

25
SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보';
26
SELECT * FROM STUDENT WHERE STU_DEPT = '기계';
27
SELECT * FROM STUDENT WHERE STU_DEPT = '전기전자';
28
SELECT * FROM STUDENT WHERE STU_HEIGHT >= 170;
29
SELECT * FROM STUDENT WHERE STU_WEIGHT >= 65;
30
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_DEPT = '기계';
31
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_DEPT = '컴퓨터정보';
32
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_DEPT = '전기전자';
33
SELECT STU_NAME FROM STUDENT WHERE STU_GENDER = 'M';
34
SELECT STU_NAME FROM STUDENT WHERE STU_GENDER = 'F';
35
SELECT * FROM STUDENT WHERE STU_DEPT != '전기전자';
36
SELECT * FROM STUDENT WHERE STU_DEPT != '기계';
37
SELECT * FROM ENROL;
SELECT STU_NO FROM ENROL WHERE ENR_GRADE >= 80;
38
SELECT * FROM STUDENT WHERE STU_NAME = '김인중';
39
SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보' AND STU_GRADE = 1;
40
SELECT * FROM STUDENT WHERE STU_DEPT = '기계' AND STU_GRADE = 2;
41
SELECT * FROM STUDENT WHERE STU_GENDER = 'F' AND STU_WEIGHT >= 60;
42
SELECT * FROM STUDENT WHERE STU_DEPT != '컴퓨터정보' AND STU_GRADE = 1;
43
SELECT * FROM STUDENT;
SELECT * FROM SUBJECT WHERE SUB_DEPT != '기계';
44
SELECT STU_NAME FROM STUDENT WHERE STU_DEPT = '컴퓨터정보' AND STU_CLASS ='A';
45
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_HEIGHT BETWEEN 160 AND 170;
46
SELECT STU_NO, STU_NAME, STU_DEPT FROM STUDENT WHERE STU_NO LIKE = '2013%';
47
SELECT * FROM STUDENT WHERE STU_GRADE = 1 OR STU_GRADE = 3;
48
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_NAME LIKE '김%%';
49
SELECT * FROM STUDENT WHERE STU_NO LIKE '%%%%20%%';
50
SELECT * FROM STUDENT WHERE STU_NO LIKE '2006%%%%';
51
SELECT * FROM STUDENT WHERE STU_NAME LIKE '%옥%';
52
SELECT * FROM STUDENT WHERE STU_HEIGHT IS NULL;
53
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_HEIGHT IS NOT NULL;
54
SELECT STU_NO, STU_NAME FROM STUDENT WHERE STU_DEPT = '기계' OR STU_DEPT = '컴퓨터정보';
55
SELECT STU_NO, STU_NAME, STU_DEPT FROM STUDENT WHERE STU_GENDER = 'M' OR STU_GRADE = 1;
56
SELECT STU_NO, STU_NAME FROM STUDENT ORDER BY STU_NO;
57
SELECT STU_NO, STU_NAME FROM STUDENT ORDER BY STU_NAME;
58
SELECT STU_NO, STU_NAME, STU_DEPT FROM STUDENT ORDER BY STU_DEPT;
59
SELECT * FROM STUDENT ORDER BY STU_GRADE DESC;
60
SELECT * FROM STUDENT ORDER BY STU_DEPT,STU_CLASS;
61
SELECT STU_NO, STU_NAME FROM STUDENT ORDER BY STU_GENDER, STU_GRADE; 
62
SELECT STU_NO, STU_NAME, LOWER(STU_GENDER) FROM STUDENT;
63
SELECT STU_NO, STU_NAME, UPPER(STU_GENDER) FROM STUDENT;
64
SELECT STU_DEPT || STU_NAME FROM STUDENT;
65
SELECT STU_DEPT || '과' || STU_GRADE || '학년' || STU_NAME || '입니다' FROM STUDENT;
66
SELECT STU_NAME, SUBSTR(STU_NAME, 0, 2) FROM STUDENT;
67
SELECT STU_NAME, STU_DEPT, SUBSTR(STU_DEPT, 2, 1) FROM STUDENT;
68
SELECT STU_NAME, LENGTH(STU_NAME) FROM STUDENT;
69
SELECT STU_DEPT, LENGTH(STU_DEPT) FROM STUDENT;
70
SELECT STU_NAME, INSTR(STU_NAME, '김', 1, 1) FROM STUDENT;
71
SELECT STU_NO, STU_NAME, STU_DEPT, INSTR(STU_DEPT, '기', 1, 1) FROM STUDENT;
72
SELECT LPAD(STU_NAME, 15, '&') FROM STUDENT;
73
SELECT RPAD(STU_NAME, 20, '%') FROM STUDENT;
74
SELECT STU_NO, STU_NAME, ROUND(STU_HEIGHT, -1) FROM STUDENT;
75
SELECT STU_NO, STU_NAME, FLOOR(STU_HEIGHT, 1) FROM STUDENT;
76
SELECT MOD(STU_HEIGHT, 30) FROM STUDENT;
77
SELECT NVL(TO_CHAR(STU_HEIGHT), '미기록') FROM STUDENT;
78
SELECT STU_NO, STU_NAME, NVL(TO_CHAR(STU_HEIGHT+STU_WEIGHT) , 'NULL값 존재') FROM STUDENT;
79
SELECT STU_NO, STU_NAME, NVL(TO_CHAR(STU_HEIGHT-STU_WEIGHT) , 'NULL값 존재') FROM STUDENT;
80
SELECT STU_NO, STU_NAME, NVL(TO_CHAR(STU_HEIGHT), '입력 요망') FROM STUDENT;
81
SELECT NVL(NULLIF('M', 'F'), 'NULL') FROM STUDENT WHERE STU_GENDER = 'M';
SELECT NULLIF('A', 'A') FROM DUAL; // 똑같으면 NULL출력
SELECT NULLIF('A', 'B') FROM DUAL; // 다르면 A출력

SELECT NVL(NULLIF('A', 'A'), '값이 동일합니다') FROM DUAL;
82
SELECT NVL(NULLIF('M', 'M'), '남자') FROM STUDENT;
83
SELECT STU_NO, STU_NAME, STU_GENDER, STU_WEIGHT,
CASE STU_GENDER WHEN 'F' THEN STU_WEIGHT-5
                WHEN 'M' THEN STU_WEIGHT+5
    ELSE STU_WEIGHT
END AS 변경된몸무게
FROM STUDENT;
84
SELECT STU_NO, STU_NAME, STU_GENDER, STU_WEIGHT,
DECODE(STU_GENDER, 'F', STU_WEIGHT+5,
'M', STU_WEIGHT-5,
STU_WEIGHT) AS 변경된몸무게
FROM STUDENT;
85
SELECT MAX(STU_HEIGHT) FROM STUDENT;
86
SELECT MIN(STU_HEIGHT) FROM STUDENT;
87
SELECT MIN(STU_WEIGHT) FROM STUDENT;
88
SELECT MIN(STU_NAME), MAX(STU_NAME) FROM STUDENT;
89
SELECT MAX(STU_HEIGHT), MAX(STU_WEIGHT), MIN(STU_HEIGHT), MIN(STU_WEIGHT) FROM STUDENT;
90
SELECT MAX(STU_NO), MIN(STU_NO) FROM STUDENT;
91
SELECT COUNT(STU_DEPT) FROM STUDENT;
92
SELECT COUNT(STU_NAME) FROM STUDENT;
93
SELECT COUNT(*) FROM STUDENT;
94
SELECT COUNT(*) FROM ENROL;
95
SELECT STU_DEPT, COUNT(STU_DEPT) FROM STUDENT GROUP BY STU_DEPT;
96
SELECT STU_DEPT, COUNT(STU_DEPT) FROM STUDENT GROUP BY STU_DEPT ORDER BY COUNT(STU_DEPT) DESC;
97
SELECT STU_GRADE, COUNT(STU_GRADE) FROM STUDENT GROUP BY STU_GRADE;
98
SELECT STU_GRADE, COUNT(STU_GRADE) FROM STUDENT GROUP BY STU_GRADE ORDER BY COUNT(STU_GRADE) DESC;
99
SELECT STU_DEPT, ROUND(AVG(STU_HEIGHT)) FROM STUDENT GROUP BY STU_DEPT;
100
SELECT STU_DEPT, ROUND(VARIANCE(STU_WEIGHT)) FROM STUDENT GROUP BY STU_DEPT;
101
SELECT STU_DEPT, STU_GRADE, AVG(STU_HEIGHT) FROM STUDENT GROUP BY STU_DEPT, STU_GRADE;
102
SELECT STU_DEPT, STU_GRADE, AVG(STU_WEIGHT) FROM STUDENT GROUP BY STU_dEPT, STU_GRADE;
103
SELECT STU_DEPT, MAX(STU_NO), MIN(STU_NO) FROM STUDENT GROUP BY STU_DEPT;
104
SELECT STU_DEPT, COUNT(STU_NO) FROM STUDENT GROUP BY STU_DEPT ORDER BY COUNT(STU_NO) DESC;
105
SELECT STU_DEPT, AVG(STU_HEIGHT) FROM STUDENT GROUP BY STU_DEPT ORDER BY AVG(STU_HEIGHT) DESC;
106
SELECT STU_DEPT, AVG(STU_WEIGHT) FROM STUDENT GROUP BY STU_DEPT ORDER BY AVG(STU_WEIGHT) DESC;
107
SELECT STU_DEPT, AVG(STU_HEIGHT) FROM STUDENT GROUP BY STU_DEPT ORDER BY AVG(STU_HEIGHT) DESC;
108
SELECT STU_DEPT, AVG(STU_HEIGHT) FROM STUDENT GROUP BY STU_DEPT ORDER BY AVG(STU_HEIGHT) > 170 DESC;

<<<<<<<<<<20200529>>>>>>>>>>>
[Join]
Eqal
SELECT ENAME, DNAME FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO;

SELECT ENAME, DNAME FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO;
NATURAL JOIN
?열의 이름이 같아야함
SELECT ENAME, DNAME FROM EMP NATURAL JOIN DEPT;

JOIN ON
?열의 이름이 다를때
SELECT ENAME, DNAME FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;

JOIN USING
SELECT ENAME, DNAME FROM EMP JOIN DEPT USING (DEPTNO);

INNER JOIN ON
SELECT ENAME, DNAME FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;

문6) 학생들이 듣고 있는 과목번호, 점수를 출력하시오.
    학번, 학생이름, 과목번호, 점수 순으로 출력바람.
    (5가지)
//열의 정의가 애매하다고 나올땐 테이블 닉네임을 지정해서 SELECT를 채워줌
SELECT * FROM STUDENT;
SELECT * FROM ENROL;
<ORACLE>
SELECT S.STU_NO, S.STU_NAME, E.SUB_NO, E.ENR_GRADE FROM STUDENT S, ENROL E WHERE S.STU_NO = E.STU_NO ORDER BY 1;
<NATURAL JOIN>
SELECT STU_NO, STU_NAME, SUB_NO, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL; //닉네임을 지정하지않음
<JOIN ON>
SELECT S.STU_NO, S.STU_NAME, E.SUB_NO, E.ENR_GRADE FROM STUDENT S JOIN ENROL E ON S.STU_NO = E.STU_NO;
<JOIN USING>
SELECT STU_NO, STU_NAME, SUB_NO, ENR_GRADE FROM STUDENT JOIN ENROL USING (STU_NO);
<INNER JOIN>
SELECT S.STU_NO, S.STU_NAME, E.SUB_NO, E.ENR_GRADE FROM STUDENT S INNER JOIN ENROL E ON S.STU_NO = E.STU_NO;
문7) 부서번호가 30이고, 급여가 1500이상인 사원의 이름, 부서명, 급여(SAL+COMM)를 출력하시오
<ORACLE>
SELECT ENAME, DNAME, (SAL+NVL(COMM, 0)) AS 급여 FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO
AND (EMP.DEPTNO = 30 AND (EMP.SAL + NVL(EMP.COMM,0)) >= 1500);
<NATURAL JOIN>
SELECT ENAME, DNAME, (SAL+NVL(COMM, 0)) AS 급여 FROM EMP NATURAL JOIN DEPT 
WHERE DEPTNO = 30 AND (SAL + NVL(COMM,0)) >= 1500;
<JOIN ON>
SELECT EMP.ENAME, DEPT.DNAME, (EMP.SAL+NVL(EMP.COMM, 0)) AS 급여 FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO
WHERE DEPT.DEPTNO = 30 AND (EMP.SAL + NVL(EMP.COMM,0)) >= 1500;
<JOIN USING>
SELECT ENAME, DNAME, (SAL + NVL(COMM, 0)) AS 급여 FROM EMP JOIN DEPT USING (DEPTNO)
WHERE DEPTNO = 30 AND (SAL + NVL(COMM,0)) >= 1500;

SELECT * FROM EMP;
SELECT * FROM DEPT;
문8) 사원수가 5명이 넘는 부서의 부서명과 사원수를 출력하시오
<ORACLE>
SELECT DNAME, COUNT(EMPNO) FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME HAVING COUNT(EMPNO) >= 5;
<NATURAL JOIN>
SELECT DNAME, COUNT(EMPNO) FROM EMP NATURAL JOIN DEPT GROUP BY DNAME HAVING COUNT(EMPNO) >= 5;
<JOIN ON>
SELECT DNAME, COUNT(EMPNO) FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME HAVING COUNT(EMPNO) >= 5;
<JOIN USING>
SELECT DNAME, COUNT(EMPNO) FROM EMP JOIN DEPT USING (DEPTNO) GROUP BY DNAME HAVING COUNT(EMPNO) >= 5;
<INNER JOIN>
SELECT DNAME, COUNT(EMPNO) FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME HAVING COUNT(EMPNO) >= 5;
문9) 각 부서의 이름과 각 부서별 가장 많은 월급의 크기를 출력하시오.
<ORACLE>
SELECT DNAME, MAX(SAL) FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME;
<NATURAL JOIN>
SELECT DNAME, MAX(SAL) FROM EMP NATURAL JOIN DEPT GROUP BY DNAME;
<JOIN ON>
SELECT DNAME, MAX(SAL) FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME;
<JOIN USING>
SELECT DNAME, MAX(SAL) FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME;
<INNER JOIN>
SELECT DNAME, MAX(SAL) FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME;
문10) ADAMS 사원이 근무하는 부서이름과 지역이름을 출력하시오
<NATURAL JOIN>
SELECT DNAME, LOC FROM EMP NATURAL JOIN DEPT WHERE ENAME = 'ADAMS';

[NON - EQUI JOIN]
= 연산자가 아닌 다른 연산자를 사용하여 JOIN을 성립시킨다
BETWEEN또는 >= <=과 같은 산술연산자
SELECT * FROM EMP;
SELECT * FROM SALGRADE;
SELECT ENAME, EMPNO, SAL, GRADE FROM EMP, SALGRADE WHERE SAL >= LOSAL AND SAL <= HISAL;
SELECT ENAME, EMPNO, SAL, GRADE FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL;

[SELF JOIN]
SELECT MY.ENAME, MY.EMPNO, MY.MGR, YOUR.ENAME, YOUR.EMPNO FROM EMP MY, EMP YOUR WHERE MY.MGR = YOUR.EMPNO;
SELECT MY.ENAME, MY.EMPNO, MY.MGR, YOUR.ENAME, YOUR.EMPNO FROM EMP MY JOIN EMP YOUR ON MY.MGR = YOUR.EMPNO;
SELECT MY.ENAME, MY.EMPNO, MY.MGR, YOUR.ENAME, YOUR.EMPNO FROM EMP MY INNER JOIN EMP YOUR ON MY.MGR = YOUR.EMPNO;

[OUTER JOIN]
SELECT ENAME, DNAME, LOC FROM EMP FULL OUTER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;

SELECT ENAME, DNAME, LOC FROM EMP RIGHT OUTER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;
=
SELECT ENAME, DNAME, LOC FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO(+);

SELECT ENAME, DNAME, LOC FROM EMP RIGHT OUTER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;
=
SELECT ENAME, DNAME, LOC FROM EMP, DEPT WHERE EMP.DEPTNO(+) = DEPT.DEPTNO;
SELECT * FROM EMP;
SELECT * FROM DEPT;
문11) 사원번호, 사원이름, 상사번호, 상사이름을 모두 추력하는 쿼리를 작성하시오.(단, 사장님도 포함하여 출력할 수 있도록 작성하시오.)
SELECT A.EMPNO, A.ENAME, B.MGR, B.ENAME FROM EMP A, EMP B WHERE A.MGR = B.EMPNO(+);
=
SELECT E1.EMPNO, E1.ENAME, E2.EMPNO, E2.ENAME FROM EMP E1 LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO;
문12) 사원번호, 사원이름, 직책, 관리자이름, 근무위치를 출력하시오.(단, 사장님도 포함하여 출력할 수 있도록 작성하시오.)
SELECT A.EMPNO, A.ENAME, A.JOB, B.ENAME, D.LOC FROM EMP A, EMP B LEFT OUTER JOIN DEPT D ON A.MGR = B.EMPNO;
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E2.ENAME, DEPT.LOC FROM EMP E1, EMP E2, DEPT WHERE E1.DEPTNO = DEPT.DEPTNO AND E1.MGR = E2.EMPNO(+);
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E2.ENAME, DEPT.LOC FROM EMP E1 JOIN DEPT ON E1.DEPTNO = DEPT.DEPTNO LEFT OUTER JOIN EMP E2 ON E1.MGR = E2.EMPNO;

SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT * FROM SALGRADE;
문13) NEWYORK이나 DALLAS 지역에 근무하는 사원들의 사원번호, 사원이름을 사원번호 순으로 검색하시오.
SELECT EMPNO, ENAME, LOC FROM EMP JOIN DEPT ON LOC = 'NEWYORK' OR LOC = 'DALLAS' ORDER BY EMPNO;
(풀이)
SELECT EMPNO, ENAME, LOC FROM EMP NATURAL JOIN DEPT WHERE LOC IN('NEWYORK','DALLAS')ORDER BY EMPNO;
문14) 부서이름이 ACCOUNTING 이거나 지역이름이 CHICAGO인 사원의 사원이름, 사원번호, 지역, 부서명을 검색하시오.
SELECT EMPNO, ENAME, LOC, DNAME FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO WHERE DNAME = 'ACCOUNTING' OR LOC = 'CHICAGO';
문15) 사원번호, 사원이름, 급여, 급여등급을 급여등급별 사원번호 순으로 검색하시오.
SELECT ENAME, EMPNO, SAL, GRADE FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL; (참고)
SELECT EMPNO, ENAME, SAL, GRADE FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL ORDER BY EMPNO;
(풀이)
SELECT EMPNO, ENAME, SAL, GRADE FROM EMP, SALGRADE WHERE EMP.SAL BETWEEN LOSAL AND HISAL ORDER BY GRADE, EMPNO;
문16) 사원JAMES의 사원번호, 이름, 급여, 급여등급, 부서명과 그의 상사이름, 상사의 부서명을 출력하시오.
(풀이)
SELECT E1.EMPNO, E1.ENAME, E1.SAL, GRADE, D1.DNAME, E2.ENAME, D2.DNAME FROM EMP E1, EMP E2, SALGRADE, DEPT D1, DEPT D2 WHERE SAL BETWEEN LOSAL AND HISAL AND E1.DEPTNO = D1.DEPTNO AND E1.MGR = E2.EMPNO AND E2.DEPTNO = D2.DEPTNO;
SELECT E1.EMPNO, E1.ENAME, E1.SAL, GRADE, D1.DNAME, E2.ENAME, D2.DNAME FROM EMP E1, EMP E2, SALGRADE, DEPT D1, DEPT D2 WHERE E1.SAL BETWEEN LOSAL AND HISAL AND E1.DEPTNO = D1.DEPTNO AND E1.MGR = E2.EMPNO AND E2.DEPTNO = D2.DEPTNO AND E1.ENAME = 'JAMES';
SELECT E1.EMPNO, E1.ENAME, E1.SAL, GRADE, DNAME, E2.ENAME, DNAME FROM EMP E1, SALGRADE, DEPT, EMP E2 WHERE E1.MGR = E2.EMPNO;
(참고)
SELECT DNAME, MAX(SAL) FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO GROUP BY DNAME;
SELECT * FROM SUBJECT;
SELECT * FROM STUDENT;
SELECT * FROM ENROL;
SELECT ENAME, DNAME FROM EMP NATURAL JOIN DEPT;
JOIN USING
SELECT ENAME, DNAME FROM EMP JOIN DEPT USING (DEPTNO);
1
SELECT * FROM STUDENT NATURAL JOIN ENROL;
2
SELECT S.STU_NO, S.STU_NAME, B.SUB_NAME, C.ENR_GRADE FROM STUDENT S, SUBJECT B, ENROL C;
3
SELECT SUB_NAME, STU_NO, ENR_GRADE FROM STUDENT NATURAL JOIN SUBJECT NATURAL JOIN ENROL;
4
SELECT SUB_ANEM, STU_NO, ENR_GRADE FROM STUDENT JOIN SUBJECT USING ON SUB
5
SELECT STU_NAME, ENR_GRADE FROM STUDENT, ENROL WHERE  STUDENT.STU_NO = ENROL.STU_NO AND ENR_GRADE >= 70;
6
SELECT STU_NAME, ENR_GRADE FROM STUDENT JOIN ENROL USING (STU_NO) WHERE ENR_GRADE >= 60;
7
SELECT STU_NAME, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL WHERE ENR_GRADE <= 70;
8
SELECT STU_NAME, SUB_NAME, SUB_PROF FROM STUDENT, SUBJECT WHERE STUDENT.STU_GRADE = SUBJECT.SUB_GRADE AND STUDENT.STU_DEPT = SUBJECT.SUB_DEPT AND STU_NAME = '김인중';
9
SELECT STU_NAME, SUB_NAME, SUB_PROF FROM STUDENT NATURAL JOIN SUBJECT WHERE STUDENT.STU_GRADE = SUBJECT.SUB_GRADE AND STUDENT.STU_DEPT = SUBJECT.SUB_DEPT AND STU_NAME='김인중';
10ZZ
김인중 학생이 수강하는 과목이름과 강의 교수를 검색하라
SELECT SUB_NAME, SUB_PROF FROM STUDENT JOIN SUBJECT USING ON STU_NAME ='김인중';
11
SELECT STU_NAME, SUB_NAME, SUB_PROF FROM STUDENT NATURAL JOIN SUBJECT WHERE SUB_NO = '101';
12
SELECT STU_NAME, STU_NO FROM STUDENT, SUBJECT WHERE SUB_NO ='101' AND STU_DEPT ='컴퓨터정보' AND STU_GRADE ='3';
13
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE SUB_NAME = '시스템분석설계' AND SUB_NAME = '소프트웨어공학';
15
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE SUB_NAME = '기계공작법' OR SUB_NAME = '기초전자실험';
17
SELECT * FROM SUBJECT;
SELECT * FROM ENROL;
SELECT STU_NAME, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL;
18
SELECT STU_NAME, SUB_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE STU_NAME = '옥한빛';
19
SELECT STU_GENDER, SUB_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE STU_GENDER = 'F';
20
SELECT STU_NAME, STU_WEIGHT, SUB_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE STU_WEIGHT >= 60;
21
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE SUB_DEPT = '컴퓨터정보';
22
SELECT COUNT(*) FROM STUDENT NATURAL JOIN ENROL WHERE ENROL.ENR_GRADE >= 70;
23
SELECT STU_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE STU_GENDER = 'F' AND SUB_PROF = '구봉규';
24
SELECT STU_NO, STU_NAME, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL WHERE ENR_GRADE > (SELECT AVG(ENR_GRADE) FROM ENROL WHERE STU_NAME ='김종헌');
25
김인중 학생의 평균 점수 보다 낮은 점수를 가진 학생의 학번과 이름을 검색
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN ENROL WHERE ENR_GRADE < (SELECT AVG(ENR_GRADE) FROM ENROL WHERE STU_NAME = '김인중');
26
전체학생의 평균점수보다 점수가 높은 학생의 학번, 이름, 과목이름, 점수를 검색하라
SELECT * FROM STUDENT;
SELECT * FROM ENROL;
SELECT * FROM SUBJECT;
SELECT STU_NO, STU_NAME, SUB_NAME, ENR_GRADE FROM STUDENT NATURAL JOIN SUBJECT NATURAL JOIN ENROL WHERE ENR_GRADE > (SELECT AVG(ENR_GRADE) FROM ENROL);
27
점수가 각 학과 학생들의 평균 점수보다 높은 학생의 학번을 검색하라
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN ENROL WHERE ENR_GRADE > (SELECT AVG(ENR_GRADE) FROM ENROL GROUP BY STU_DEPT);
28
기계과의 최거 점수 학생보다 최고 점수가 높은 학과의 학과명과 점수를 입력하라 ??
SELECT STU_DEPT, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL GROUP BY STU_DEPT, ENR_GRADE HAVING MAX(ENR_GRADE) > (SELECT MAX(ENR_GRADE) FROM ENROL WHERE STU_DEPT = '기계');
SELECT STU_DEPT, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL WHERE ENR_GRADE > (SELECT MAX(ENR_GRADE) FROM STUDENT WHERE STU_DEPT = '기계');
SELECT MAX(ENR_GRADE) FROM STUDENT NATURAL JOIN ENROL WHERE STU_DEPT = '기계'
SELECT STU_DEPT, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL;
29
컴퓨터정보과 학생들의 평균 점수를 구해 학생들의 학번과 이름 평균 점수를 성적 순으로 검색하라 
SELECT STU_NO, STU_NAME, AVG(ENR_GRADE) FROM STUDENT NATURAL JOIN ENROL WHERE STU_DEPT = '컴퓨터정보';
SELECT STU_NO, STU_NAME, AVG(ENR_GRADE) FROM STUDENT NATURAL JOIN ENROL GROUP BY STU_DEPT, STU_NAME, STU_NO, ENR_GRADE HAVING STU_DEPT = '컴퓨터정보';
30
시스템분석설계 과목을 수강한 학생들의 학번, 이름, 점수를 성적 순으로 검색하시오
SELECT STU_NO, STU_NAME, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL NATURAL JOIN SUBJECT WHERE SUB_NAME = '시스템분석설계' ORDER BY ENR_GRADE;
31
2과목 이상 수강한 학생들의 학번, 이름, 수강과목 수를 수강과목이 많은 순으로 검색하라 ??
SELECT STU_NO, STU_NAME, COUNT(SUB_NO) FROM STUDENT NATURAL JOIN SUBJECT WHERE COUNT(SUB_NO) >= 2;
SELECT STU_DEPT, STU_NO, STU_NAME, COUNT(SUB_NAME) FROM STUDENT NATURAL JOIN SUBJECT GROUP BY STU_DEPT, STU_NO, STU_NAME HAVING COUNT(SUB_NAME) >= 2;
32
1과목을 수강한 학생들의 학번, 이름을 학과별 학번 순으로 검색하라
SELECT STU_NO, STU_NAME, STU_DEPT FROM STUDENT NATURAL JOIN SUBJECT WHERE COUNT(SUB_NAME) >= 1;
33
컴퓨터 정보과 학생들 중 평균점수가 최고인 학생의 학번, 이름, 평균 점수를 검색
ELECT STU_NO, STU_NAME, MAX(AVG(ENR_GRADE)) FROM STUDENT NATURAL JOIN ENROL GROUP BY STU_DEPT HAVING STU_DEPT = '컴퓨터정보';
34
컴퓨터개론과 시스템분석설계 과목을 수강하는 학생의 학번, 이름을 학번 순으로 검색하라
SELECT STU_NO, STU_NAME, ENR_GRADE FROM STUDENT NATURAL JOIN ENROL NATURAL JOIN SUBJECT WHERE SUB_NAME = '시스템분석설계' ORDER BY ENR_GRADE;
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE SUB_NAME = ANY('컴퓨터개론', '시스템분석설계') AND SUB_DEPT = STU_DEPT ORDER BY STU_NO;
SELECT STU_NO, STU_NAME FROM STUDENT NATURAL JOIN SUBJECT WHERE SUB_NAME = '컴퓨터개론' AND SUB_NAME = '시스템분석설계';
<<<<<<<<<<<<20200601>>>>>>>>>>>>>>
[Sub Query]
WHERE 절
HAVING 절
INSERT INTO 절
UPDATE SET 절
SELECT 절
SELECT * FROM (SUB QUERY) WHERE (SUB QUERY)GROUP BY HAVING (SUB QUERY)

문1)평균 급여보다 많이 받는 사원의 이름, 급여를 구하여라
SELECT ENAME, SAL FROM EMP WHER SAL > (SELECT AVG(SAL) FROM EMP);
평균급여 SELECT AVG(SAL) FROM EMP

문2)ALLEN 보다 급여를 많이 받는 사원의 이름,직무, 사원번호를 출력하시오
SELECT ENAME, JOB, EMPNO FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'ALLEN');

문3) 진현무 학생보다 키가 큰 학생들의 이름, 학번, 키를 출력하시오
SELECT STU_NAME, STU_NO, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT > (SELECT STU_HEIGHT FROM STUDENT WHERE STU_NAME = '진현무');
SELECT STU_NAME, STU_NO, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT > (진현무 학생 키)
[JOIN 방법]
SELECT S1.STU_NAME, S1.STU_NO, S1.STU_hEIGHT FROM STUDENT S1, STUDENT S2 WHERE S1.STU_HEIGHT > S2.STU_HEIGHT AND S2.STU_NAME = '진현무';

SELECT * FROM STUDENT;
문4) 학과별 평균 신장이 가장 큰 학과의 학과, 평균신장을 출력하시오.
SELECT STU_DEPT, ROUND(AVG(STU_HEIGHT)) FROM STUDENT GROUP BY STU_DEPT HAVING AVG(STU_HEIGHT) = (SELECT MAX(AVG(STU_HEIGHT)) FROM STUDENT GROUP BY STU_DEPT);
SELECT STU_DEPT, AVG_HEIGHT FROM (SELECT STU_DEPT, ROUND(AVG(STU_HEIGHT)) AS AVG_HEIGHT FROM STUDENT GROUP BY STU_DEPT) WHERE AVG_HEIGHT = (SELECT MAX(AVG(STU_HEIGHT)) FROM STUDENT GROUP BY STU_DEPT);

문5) 부서 평균급여가 전체 직원 평균 급여보다 많은 부서의 이름, 부서 평균급여를 출력하시오
SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT DNAME, ROUND(AVG(SAL)) FROM EMP NATURAL JOIN DEPT GROUP BY DNAME, DEPTNO HAVING AVG(SAL) > (SELECT AVG(SAL) FROM EMP);

문6) 기계과 학생들 중 학년별 평균 신장이 160 이상인 학년과 신장을출력하시오.
SELECT STU_GRADE, AVG(STU_HEIGHT) FROM STUDENT GROUP BY STU_DEPT HAVING AVG(STU_HEIGHT) > 160 AND STU_DEPT = '기계';
SELECT STU_DEPT, STU_GRADE, ROUND(AVG(STU_HEIGHT)) FROM STUDENT WHERE STU_DEPT = '기계' GROUP BY STU_GRADE, STU_DEPT HAVING AVG(STU_HEIGHT) >= 160;

문7) CHICAGO에서 근무하지 않은 모든 사원의 정보를 출력하시오
SELECT * FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO WHERE LOC != 'CHICAGO';
SELECT * FROM EMP WHERE DEPTNO != (SELECT DEPTNO FROM DEPT WHERE LOC = 'CHICAGO');

문8) 20번 부서의 최대급여보다 최대급여가 많은 부서의 부서번호, 부서이름, 최대급여를 검색하시오.
SELECT DEPTNO, DNAME, MAX(EMP.SAL) FROM EMP JOIN DEPT USING(DEPTNO) GROUP BY DEPTNO, DNAME HAVING MAX(SAL) > (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 20);

문9) SALESMAN의 평균 커미션을 출력하시오.
SELECT ROUND (AVG(NVL(COMM,0))) FROM EMP WHERE JOB = 'SALESMAN';
SELECT AVG(COM) FROM (SELECT AVG(NVL(COMM,0)) AS COM FROM EMP WHERE JOB = 'SALESMAN');


문10) 학과별 평균 몸무게보다 몸무게가 많은 학과별 학생들의 학번, 이름 학과명, 몸무게를 출력하시오.
SELECT STU_NO, STU_NAME, STU_DEPT, AVG(STU_WEIGHT) FROM STUDENT GROUP BY STU_DEPT HAVING 
SELECT STU_NO, STU_NAME, STU_DEPT, STU_WEIGHT FROM STUDENT, (SELECT STU_DEPT, AVG(STU_WEIGHT) AS AVG_WEIGHT FROM STUDENT GROUP BY STU_DEPT) AVG_TABLE WHERE STUDENT.STU_WEIGHT > AVG_TABLE.AVG_WEIGHT AND STUDENT.STU_DEPT = AVG_TABLE.STU_DEPT;
SELECT STU_NO, STU_NAME, STUDENT.STU_DEPT, STU_WEIGHT
FROM STUDENT, (SELECT STU_DEPT, AVG(STU_WEIGHT) AS AVG_WEIGHT FROM STUDENT GROUP BY STU_DEPT) AVG_TABLE
WHERE STUDENT.STU_WEIGHT > AVG_TABLE.AVG_WEIGHT AND STUDENT.STU_DEPT = AVG_TABLE.STU_DEPT;
(학과별 평균 몸무게)
SELECT STU_DEPT, AVG(STU_WEIGHT) FROM STUDENT GROUP BY STU_DEPT;

[MULTI ROW SUBQUERY]
각 부서별 최소 급여를 받는 사원의 이름과 급여를 구하라
SELECT ENAME, SAL FROM EMP WHERE (DEPTNO, SAL) IN(SELECT DEPTNO, MIN(SAL) FROM EMP GROUP BY DEPTNO);

SELECT DEPTNO, MIN(SAL) FROM EMP GROUP BY DEPTNO;

각 반에서 가장 키가 큰 학생들의 이름, 전공, 반, 키를 출력하시오
SELECT * FROM STUDENT;
SELECT STU_NAME, STU_DEPT, STU_CLASS, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT IN(SELECT MAX(STU_HEIGHT) FROM STUDENT GROUP BY STU_CLASS);
SELECT STU_NAME, STU_DEPT, STU_CLASS, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT = ANY(SELECT MAX(STU_HEIGHT) FROM STUDENT GROUP BY STU_CLASS);
SELECT STU_NAME, STU_DEPT, STU_CLASS, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT = SOME(SELECT MAX(STU_HEIGHT) FROM STUDENT GROUP BY STU_CLASS);

// 1, 2, 3
//1
SELECT STU_GRADE FROM STUDENT WHERE STU_GRADE > ANY(1, 2)
//2
SELECT STU_GRADE FROM STUDENT WHERE STU_GRADE < ANY (1, 2)
//1 OR 2
SELECT STU_GRADE FROM STUDENT WHERE STU_GRADE = ANY(1, 2)
// 2
SELECT STU_GRADE FROM STUDENT WHERE STU_GRADE > ALL (1,2) 
// 1
SELECT STU_GRADE FROM STUDENT WHERE STU_GRADE < ALL (1, 2)
// 1 OR 2
SELECT STU_GRADE FROM STUDENT WHERE STU_GRADE = ANY (1, 2)
//오류
SELECT STU_GRAD FROM STUDENT WHERE STU_GRADE = ALL( 1, 2)

SELECT * FROM STUDENT A WHERE EXISTS (SELECT * FROM STUDENT B WHERE A.STU_NO = B.STU_NO AND STU_GENDER = 'M')

문 13) 20번 부서 사원의 사원직무(job)와 같은 사원직무를 가진 다른 부서(DEPTNO)의 사원정보를 모두 출력하시오(IN, ANY, SOM)
SELECT STU_NAME, STU_DEPT, STU_CLASS, STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT IN(SELECT MAX(STU_HEIGHT) FROM STUDENT GROUP BY STU_CLASS);
SELECT * FROM EMP;
SELECT * FROM EMP WHERE DEPTNO IN(SELECT DEPTNO FROM EMP WHERE DEPTNO != 20);
(풀이)
SELECT * FROM EMP WHERE DEPTNO != 20 AND JOB = SOME (SELECT DISTINCT JOB FROM EMP WHERE DEPTNO = 20);
문 14) 부서별로 가장 급여를 많이 받는 사원정보를 모두 출력하시오(IN, ANY, SOM)
SELECT * FROM EMP WHERE SAL IN(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
SELECT * FROM EMP WHERE (DEPTNO, SAL) IN(SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

문 15) 직급이 매니저인 사람이 속한 직급,부서이름, 부서번호, 지역을 출력하시오.
SELECT * FROM DEPT;
SELECT JOB, DNAME, DEPTNO, LOC FROM EMP NATURAL JOIN DEPT GROUP BY JOB, DNAME, DEPTNO, LOC HAVING EMP.JOB = 'MANAGER';
SELECT DISTINCT JOB, DNAME, DEPTNO, LOC FROM EMP NATURAL JOIN DEPT WHERE DEPTNO IN(SELECT DEPTNO FROM EMP WHERE JOB = 'MANAGER') ORDER BY DEPTNO;

문16) 영업 사원이 받는 최소급여보다 많이 받는 사원들의 이름, 급여, 부서명을 출력하시오
SELECT ENAME, SAL, DNAME FROM EMP NATURAL JOIN DEPT WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE JOB = 'SALESMAN');
(풀이)
SELECT ENAME, SAL, DNAME FROM EMP NATURAL JOIN DEPT WHERE SAL > ANY(SELECT MIN(SAL) FROM EMP WHERE JOB = 'SALESMAN');
(영업사원이 받는 최소급여)
SELECT MIN(SAL) FROM EMP WHERE JOB = 'SALESMAN';


문17) 급여가 모든 부서들의 평균급여보다 많은 사원들의 모든 정보를 출력하시오
SELECT * FROM EMP WHERE SAL > (SELECT AVG(SAL) FROM EMP);
(풀이)
SELECT * FROM EMP WHERE SAL > ALL(SELECT AVG(SAL) FROM EMP GROUP BY DEPTNO);

문18) 영업 사원들보다 급여를 많이 받는 사원의 사원이름, 급여를 출력하시오
(풀이)
SELECT ENAME, SAL FROM EMP WHERE SAL > ALL(SELECT SAL FROM EMP WHERE JOB = 'SALESMAN');
(영업사원 급여)
SELECT SAL FROM EMP WHERE JOB = 'SALESMAN')

[SET 연산자]
(UNION) QUERY 결과값이 합이면 중복 제거
(UNION ALL) QUERY 결과값이 합이면 중복 포함 속도 우수
(INTERSECT) QUERY 결과값이 중복값
(MINUS) 첫 번째 QUERY 결과값에서 두 번째 QUERY 결과값을 뺀 값

SELECT * FROM EMP WHERE DEPTNO = 10
UNION SELECT * FROM EMP WHERE DEPTNO IN(10, 20);

SELECT * FROM EMP WHERE DEPTNO = 10
INTERSECT SELECT * FROM EMP WHERE DEPTNO IN(10, 20);

SELECT * FROM EMP WHERE DEPTNO IN(10, 20)
MINUS SELECT * FROM EMP WHERE DEPTNO = 10;

UNION ALL, UNION, INTERSECT, MINUS
문19) 전기전자과인 학생들과 컴퓨터 정보과인 학생들의 전체정보를 나타내시오
[UNION]
SELECT * FROM STUDENT WHERE STU_DEPT = '전기전자'
UNION SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보';
[UNION ALL]
SELECT * FROM STUDENT WHERE STU_DEPT = '전기전자'
UNION ALL SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보';
[INTERSECT]
SELECT * FROM STUDENT WHERE STU_DEPT = '전기전자'
INTERSECT SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보';
[MINUS]
SELECT * FROM STUDENT WHERE STU_DEPT = '전기전자'
MINUS SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보';

문20) 전체 학생 정보에서 1학년 학생 정보를 제외하고 전체정보를 출력하시오.
SELECT * FROM STUDENT
MINUS SELECT * FROM STUDENT WHERE STU_GRADE = 1;


문21) 전체 학생정보에서 기계과이면서 1학년생인 정보를 출력하시오.
SELECT * FROM STUDENT
INTERSECT SELECT * FROM STUDENT WHERE STU_DEPT = '기계' AND STU_GRADE = 1;

[통계함수]
ROLLUP
SELECT DNAME, JOB, SUM(SAL) FROM EMP NATURAL JOIN DEPT GROUP BY ROLLUP (DNAME, JOB)

SELECT DNAME,JOB, SUM(SAL) FROM EMP NATURAL JOIN DEPT GROUP BY DNAME, JOB UNION ALL
SELECT DNAME, NULL, SUM(SAL) FROM EMP NATURAL JOIN DEPT GROUP BY DNAME UNION ALL
SELECT NULL, NULL, SUM(SAL) FROM EMP NATURAL JOIN DEPT

SELECT DNAME, JOB, SUM(SAL) FROM EMP NATURAL JOIN DEPT GROUP BY GROUPING SETS (DNAME, JOB) ORDER BY 1,2;

<<<<<<<<<<20200602>>>>>>>>>>
[CREATE]
(데이터는 안가져오고 제약조건X 구조만 가져올때)
CREATE TABLE T_EMP AS 
SELECT * FROM EMP WHERE 1=2;

[INSERT]
INSERT INTO T_EMP (EMPNO, ENAME, JOB) VALUES (7903, 'DAVID', 'CLERK');

INSERT INTO T_EMP SELECT * FROM EMP;

INSERT INTO "C##ORA_USER"."T_EMP" (EMPNO, ENAME, JOB) VALUES ('7904', 'DAVIA', 'CLERK')

INSERT INTO T_EMP (EMPNO, ENAME) SELECT EMPNO, ENAME FROM T_EMP WHERE EMPNO = 7903;

문1) TT_EMP 테이블을 새로 만들고 'SMITH'를 제외한 모든 사원의 정보를 삽입하시오
CREATE TABLE TT_EMP AS SELECT * FROM EMP WHERE ENAME <> 'SMITH';

CREATE TABLE TT_EMP AS SELECT * FROM EMP WHERE 1 = 2;

INSERT INTO TT_EMP SELECT * FROM EMP WHERE ENAME != 'SMITH';

SELECT * FROM TT_EMP;
문2) TT_EMP 테이블에 아래 정보를 넣으시오
이름 : SON
월급 : 20000
보너스 : 20%
사원번호 : 70
INSERT INTO TT_EMP (ENAME, SAL, COMM, EMPNO) VALUES ('SON', 20000, 20000*0.2, 70);


문3) TT_EMP 테이블에 사원번호 9999, 사원이름 MIKE를 입력하시오.
INSERT INTO TT_EMP (EMPNO, ENAME) VALUES (9999, 'MIKE');


[UPDATE]
예) SON이 월급을 30000으로 인상하여 받게되었다.
UPDATE TT_EMP SET SAL = 30000 WHERE ENAME = 'SON';

UPDATE TT_EMP SET SAL = 40000, COMM = 40000*0.3 WHERE ENAME = 'SON';

UPDATE TT_EMP SET SAL = (SELECT SAL*0.5 FROM TT_EMP WHERE ENAME = 'SON') WHERE ENAME = 'SON';

문4) SON의 보너스를 15%로 조정하시오 그리고 입사일을 오늘날짜로 지정
UPDATE TT_EMP SET COMM = (SELECT SAL*0.15 FROM TT_EMP WHERE ENAME = 'SON') WHERE ENAME ='SON';
UPDATE TT_EMP SET COMM = COMM * 0.15 HIREDATE = SYSDATE WHERE EMPNO = 7;
문5)SON보다 적게 월급을 받고 있는 사람들의 월급을 10% 인상하시오
UPDATE TT_EMP SET SAL = NVL(SAL, 0) * 1.1 WHERE NVL(SAL, 0) < (SELECT SAL FROM TT_EMP WHERE ENAME = 'SON');
문6) COMM이 NULL 값인 모든 사원의 COMM 을 0으로 변경하시오
UPDATE TT_EMP SET COMM = 0 WHERE COMM IS NULL;
SELECT * FROM SALGRADE;
SELECT * FROM TT_EMP;
문7)월급 등급이 3인 직원들의 월급을 15% 인상하여 저장하시오.
UPDATE TT_EMP SET SAL = SAL*1.15 WHERE EMPNO IN(SELECT EMPNO FROM TT_EMP NATURAL JOIN SALGRADE WHERE TT_EMP.SAL BETWEEN LOSAL AND HISAL AND GRADE = 3);
(월급 등급이 3인 사원번호)
문8)DALLAS에서 일하는 직원들의 COMM을 100씩 추가하시오.
UPDATE TT_EMP SET COMM = NVL(COMM, 0) + 100 WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS');
(DALLAS에서 일하는 직원 사원번호)
SELECT DEPTNO FROM DEPT WHERE LOC = 'DALLAS'
문9)SCOTT의 상급자를 BLAKE로 변경하시오
UPDATE TT_EMP SET MGR = (SELECT EMPNO FROM EMP WHERE ENAME = 'BLAKE') WHERE EMPNO = (SELECT EMPNO FROM EMP WHERE ENAME = 'SCOTT');
(BLAKE)
SELECT EMPNO FROM EMP WHERE ENAME = 'BLAKE'
(SCOTT)
SELECT EMPNO FROM EMP WHERE ENAME = 'SCOTT'
[DELETE]
SELECT * FROM TT_EMP;
DELETE FROM TT_EMP WHERE EMPNO = 70;

문10) 사원번호 7902번 사원정보를 모두 삭제하시오.
DELETE FROM TT_EMP WHERE EMPNO = 7902;
문11) 평균급여 보다 적게 받는 사원을 모두 삭제하시오.
DELETE FROM TT_EMP WHERE SAL < (SELECT AVG(SAL) FROM TT_EMP);
문12) TT_EMP 테이블의 데이터를 모두 삭제하시오.
DELETE FROM TT_EMP WHERE 1=1;
[MERGE]
MERGE INTO TT_EMP USING EMP ON (TT_EMP.EMPNO = EMP.EMPNO) 
WHEN MATCHED THEN 
UPDATE SET TT_EMP.ENAME = EMP.ENAME
WHEN NOT MATCHED THEN
INSERT (EMPNO, ENAME, JOB)VALUES (7, 'SON', 'SOCCERPLAYER')

MERGE INTO TT_EMP
USING DUAL
ON (1=2)
WHEN MATCHED THEN UPDATE SET TT_EMP.ENAME = 'SON'
WHEN NOT MATCHED THEN
INSERT (EMPNO, ENAME, JOB) VALUES (7, 'SON', 'PLAYER')

S_EMP
CREATE TABLE S_EMP AS SELECT * FROM EMP WHERE EMPNO = 7902;

T_EMP
CREATE TABLE T_EMP AS
SELECT * FROM EMP
WHERE EMPNO != 7902;


SELECT * FROM S_EMP;
SELECT * FROM T_EMP;
MERGE INTO T_EMP USING S_EMP 
ON (T_EMP.EMPNO = S_EMP.EMPNO)
WHEN MATCHED THEN
UPDATE SET T_EMP.ENAME = '7777'
WHEN NOT MATCHED THEN
INSERT(EMPNO, ENAME, JOB) VALUES (7902, 'FORD', 'ANALYST');

MERGE INTO T_EMP USING S_EMP 
ON (T_EMP.EMPNO = S_EMP.EMPNO)
WHEN MATCHED THEN
UPDATE SET T_EMP.ENAME = '7777'
WHEN NOT MATCHED THEN
INSERT(EMPNO, ENAME, JOB) VALUES (7902, 'FORD', 'ANALYST');

MERGE INTO T_EMP
USING S_EMP
ON (T_EMP.EMPNO) = S_EMP.EMPNO)
WHEN MATCHED THEN
    UPDATE SET T_EMP.ENAME = 'SON'
    DELETE WHERE (T_EMP.EMPNO = 7902)
WHEN NOT MATCHED THEN
    INSERT (EMPNO, ENAME, JOB)
    VALUES (7902, 'FORD', 'ANALYST');
    
MERGE INTO T_EMP USING S_EMP 
ON (T_EMP.EMPNO = S_EMP.EMPNO)
WHEN MATCHED THEN
UPDATE SET T_EMP.ENAME = '7777'
WHEN NOT MATCHED THEN
INSERT(EMPNO, ENAME, JOB) VALUES (7902, 'FORD', 'ANALYST');
    
문13) T_EMP에 다음정보를 입력하시오
사원번호 : 1112
이름 : PARK
월급 : 2000
데이터가 존재하면 UPDATE
데이터가존재하지않으면 INSERT
(단, S_EMP와 대조하여 진행할것)
MERGE INTO T_EMP USING S_EMP
ON (T_EMP.EMPNO = S_EMP.EMPNO)
WHEN MATCHED THEN
UPDATE SET T_EMP.ENAME = 'PARK'
WHEN NOT MATCHED THEN
INSERT (EMPNO, ENAME, SAL) VALUES (1112, 'PARK', 2000);

문14) 
CREATE TABLE T_STUDNET AS SELECT * FROM STUDENT WHERE 1=2;

MERGE INTO T_STUDENT
USING (SELECT * FROM STUDENT WHERE STU_DEPT = '컴퓨터정보' )
ON (T.STU_NO = S.STU_NO)
WHEN MATCHED THEN
UPDATE SET T.STU_WEIGHT = T.STU_WEIGHT + DECODE(STU_GRADE, 3, 30, 2,20, 1,20)
WHEN NOT MATCHED THEN
INSERT VALUES (S.STU_NO, S.STU_NAME, S.STU_DEPT, S.STU_GRADE, S.STU_CLASS, S.STU_GENDER, S.STU_HEIGHT, S.STU_WEIGHT + DECODE(STU_GRADE,

문15 외국인 학생 테이블(fore_student) 작성시에 오류가 
     발생하였다. 외국인 학생 MAKE를 student 테이블에 
     추가합니다. 외국인 학생들의 클래스는 모두 A반으로 
     변경하고 추가된 MAKR 를 fore_student에 저장하시오.

	<오류 발생 명령문>
	CREATE TABLE fore_student
	as select * from student 
	where stu_grade = 1;
        
            <MAKE 정보> -> STUDENT 테이블에 추가(INSERT)
	STU_NO STU_NAME STU_GRADE
             1111     MAKE       1학년
             
CREATE TABLE FORE_STUDENT AS SELECT * FROM WHERE STU_GRADE = 1;
INSERT INTO STUDENT (STU_NO, STU_NAME, STU_GRADE) VALUES (1111, 'MAKE', 1);

MERGE INTO FORE_STUDENT F USING STUDENT S ON (F.STU_NO = S.STU_NO)
WHEN MATCHED THEN
    UPDATE SET F.STU_CLASS ='A'
WHEN NOT MATCHED THEN
    INSERT (F.STU_NO, F.STU_NAME, F.STU_DEPT, F.STU_GRADE, F.STU_CLASS, F.STU_GENDER, F.STU_HEIGHT, F.STU_WEIGHT)
    VALUES (S.STU_NO, S.STU_NAME, S.STU_DEPT, S.STU_GRADE, S.STU_CLASS, S.STU_GENDER, S.STU_HEIGHT, S.STU_WEIGHT)
    WHERE S.STU_GRADE = 1;
                                                                                                                            3,30,
                                                                                                                            2,20,
                                                                                                                            1,20));
1
CREATE TABLE STUDENT1 AS SELECT * FROM STUDENT WHERE 1=2;
SELECT * FROM STUDENT1;
CREATE TABLE SUBJECT1 AS SELECT * FROM SUBJECT WHERE 1=2;
CREATE TABLE ENROL1 AS SELECT * FROM ENROL WHERE 1=2;
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20093075, '옥한빛', '기계', 1, 'C', 'M', 177 ,80);
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20093088, '이태연', '기계', 1, 'C', 'F', 162 ,50);
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20093054, '유가인', '기계', 2, 'C', 'F', 154, 47);
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20072088, '조민우', '전기전자', 1, 'C', 'M', 188, 90);
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20062021, '심수정', '전기전자', '2', 'A', 'F', 168,45);
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20061062, '김인중', '컴퓨터정보', 1, 'B', 'M', 166,67);
INSERT INTO STUDENT1 (STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT)
VALUES (20061077, '진현무', '컴퓨터정보', 2, 'C', 'M', 174, 64);

SELECT * FROM SUBJECT1;
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (111, '데이터베이스', '이재영', 2, '컴퓨터정보');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (110, '자동제어', '정순정', 2 ,'전기전자');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (109, '자동화설계', '박민영', 3, '기계');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (101, '컴퓨터개론', '강종영', 3, '컴퓨터정보');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (102, '기계공작법', '김태영', 1, '기계');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (103, '기초전자실험', '김유석', 1, '전기전자');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (104, '시스템분석설계', '강석현', 3, '컴퓨터정보');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (105, '기계요소설계', '김명성', 1, '기계');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (106, '전자회로실험', '최영민', 3, '전기전자');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (107, 'CAD응용실습', '구봉규', 2, '기계');
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES (108, '소프트웨어공학', '권민성', 1, '컴퓨터정보');
SELECT * FROM ENROL1;
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (101,20071001,80);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (101,20071001,56);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (106,20052003,72);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (103,20072088,45);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (101,20071025,65);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (104,20071025,65);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (108,20061062,81);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (107,20093054,41);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (102,20093075,66);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (105,20093075,56);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (102,20093088,61);
INSERT INTO ENROL1 (SUB_NO, STU_NO, ENR_GRADE)
VALUES (105,20093088,78);

1
INSERT INTO STUDENT1(STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER, STU_HEIGHT, STU_WEIGHT) VALUES (20101059, '조병준', '컴퓨터정보', 1, 'B', 'M', 164, 70);
2
INSERT INTO STUDENT1(STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER) VALUES (20102038, '남지선', '전기전자', 1, 'C', 'F');
3
SELECT * FROM STUDENT1;
2009075학생과 같은 학년 반을 갖는 남학생
INSERT INTO STUDENT1(STU_NO, STU_NAME, STU_DEPT, STU_GRADE, STU_CLASS, STU_GENDER) VALUES (20103009, '박소신', '기계', (SELECT STU_GRADE FROM STUDENT1 WHERE STU_NO = 20093075), 'C', 'M');
4
INSERT INTO STUDENT1 SELECT * FROM STUDENT WHERE STU_GRADE = 3;
5
ROLLBACK;
DELETE FROM STUDENT1 WHERE STU_NO = 20151062;
SELECT * FROM STUDENT;
SELECT * FROM STUDENT1;
SELECT * FROM SUBJECT;
SELECT * FROM ENROL1;
UPDATE STUDENT1 SET STU_CLASS = 'B' WHERE STU_NO = 20131001;
6
UPDATE STUDENT1 SET STU_HEIGHT = STU_HEIGHT+ 2 WHERE STU_NO = 20072088;
7
UPDATE STUDENT1 SET STU_GRADE = STU_GRADE + 1;
8
UPDATE STUDENT1 SET STU_DEPT = '컴퓨터정보', STU_NO = 20061021 WHERE STU_NO = 20062021;
9
UPDATE ENROL1 SET ENR_GRADE = ENR_GRADE - 10 WHERE SUB_NO = (SELECT SUB_NO FROM SUBJECT WHERE SUB_NAME ='전자회로실험'); 
10
UPDATE ENROL1 SET ENR_GRADE = 0 WHERE STU_NO = 20061062;
11
DELETE FROM STUDENT1 WHERE STU_NO = 20093088;
12
INSERT INTO SUBJECT1 (SUB_NO, SUB_NAME, SUB_PROF, SUB_GRADE, SUB_DEPT)
VALUES(112, '자동화시스템', '고종민', 3, '기계');
13
UPDATE SUBJECT1 SET SUB_NO = 501 WHERE SUB_NO = 110;
14
DELETE FROM SUBJECT1 WHERE SUB_NO = 101;
15
SELECT SUB_NO FROM SUBJECT1 GROUP BY SUB_NO
SELECT SUB_NO FROM ENROL1;
SELECT * FROM ENROL1;
ROLLBACK;
UPDATE ENROL1 SET SUB_NO = 999 WHERE SUB_NO IN(SELECT SUB_NO FROM SUBJECT1);
UPDATE ENROL1 SET SUB_NO = 999 WHERE SUB_NO = (SELECT SUB_NO FROM SUBJECT1);
ROLLBACK;
SELECT * FROM SUBJECT1;
ROLLBACK;
16
SELECT * FROM ENROL1;
UPDATE ENROL1 SET STU_NO = 99999999 WHERE STU_NO IN(SELECT STU_NO FROM STUDENT1);
17
DELETE FROM ENROL1 WHERE SUB_NO = 999;
18
DELETE FROM ENROL1 WHERE STU_NO = 99999999;
19
DELETE FROM SUBJECT WHERE SUB_NO = (SELECT SUB_NO FROM ENROL);
20
DELETE FROM ENROL1;



1
CREATE TABLE CUSTOMER (
C_CODE VARCHAR2(4) CONSTRAINT PK_CUSTOMER PRIMARY KEY,
C_NAME VARCHAR2(30),
C_CEO VARCHAR2(12),
C_ADDR VARCHAR2(100),
C_PHONE VARCHAR2(13)
);

CREATE TABLE TRADE (
T_SEQ NUMBER CONSTRAINT PK_TRADE PRIMARY KEY,
P_CODE CHAR(3),
C_CODE VARCHAR2(4),
T_DATE DATE,
T_QTY NUMBER,
T_COSE NUMBER,
T_TAX NUMBER
);

CREATE TABLE PRODUCT (
P_CODE CHAR(3) CONSTRAINT PK_PRODUCT PRIMARY KEY,
P_NAME VARCHAR(30),
P_COSE NUMBER,
P_GROUP VARCHAR2(30) );

CREATE TABLE STOCK (
P_CODE CHAR(3)

CREATE TABLE DEPT(
   DEPTNO NUMBER(2) CONSTRAINT pk_dept PRIMARY KEY,
   DNAME VARCHAR2(14),
   LOC VARCHAR2(13)
);
1
CREATE TABLE PRODUCT (
P_CODE CHAR(3) CONSTRAINT PK_PRODUCT PRIMARY KEY,
P_NAME VARCHAR(30),
P_COSE NUMBER,
P_GROUP VARCHAR2(30) );
2
DESC PRODUCT;
3
INSERT INTO PRODUCT VALUES ('101','19인치 모니터', 150000, '모니터');
INSERT INTO PRODUCT VALUES ('102','22인치 모니터', 200000, '모니터');
INSERT INTO PRODUCT VALUES ('103','25인치 모니터', 260000, '모니터');
INSERT INTO PRODUCT VALUES ('201','유선마우스', 7000, '마우스');
INSERT INTO PRODUCT VALUES ('202','무선마우스', 18000, '마우스');
INSERT INTO PRODUCT VALUES ('301','유선키보드', 8000, '키보드');
INSERT INTO PRODUCT VALUES ('302','무선키보드', 22000, '키보드');
INSERT INTO PRODUCT VALUES ('401','2채널 스피커', 10000, '스피커');
INSERT INTO PRODUCT VALUES ('402','5.1채널 스피커', 120000, '스피커');

4
SELECT * FROM PRODUCT;
5
CREATE TABLE TRADE (
T_SEQ NUMBER CONSTRAINT PK_TRADE PRIMARY KEY,
P_CODE CHAR(3),
C_CODE VARCHAR2(4),
T_DATE DATE,
T_QTY NUMBER,
T_COSE NUMBER,
T_TAX NUMBER
);
6
desc trade;
7
INSERT INTO TRADE VALUES (61, '131', '101', TO_DATE('2016-04-01','YYYY-MM-DD'), 10, 150000, 150000);
INSERT INTO TRADE VALUES (5, '102', '102', TO_DATE('2016-04-26','YYYY-MM-DD'), 8, 200000, 160000);
INSERT INTO TRADE VALUES (8, '103', '101', TO_DATE('2016-05-20','YYYY-MM-DD'), 2, 260000, 52000);
INSERT INTO TRADE VALUES (3, '201', '103', TO_DATE('2016-04-13','YYYY-MM-DD'), 7, 7000, 4900);
INSERT INTO TRADE VALUES (2, '201', '101', TO_DATE('2016-04-12','YYYY-MM-DD'), 5, 7000, 3500);
INSERT INTO TRADE VALUES (9, '202', '104', TO_DATE('2016-06-02','YYYY-MM-DD'), 8, 18000, 14400);
INSERT INTO TRADE VALUES (6, '301', '103', TO_DATE('2016-05-02','YYYY-MM-DD'), 12, 8000, 9600);
INSERT INTO TRADE VALUES (10, '302', '103', TO_DATE('2016-06-09','YYYY-MM-DD'), 9, 22000, 19800);
INSERT INTO TRADE VALUES (4, '401', '104', TO_DATE('2016-04-20','YYYY-MM-DD'), 15, 10000, 15000);
INSERT INTO TRADE VALUES (11, '401', '105', TO_DATE('2016-06-15','YYYY-MM-DD'), 20, 10000, 20000);
INSERT INTO TRADE VALUES (7, '402', '102', TO_DATE('2016-05-08','YYYY-MM-DD'), 5, 120000, 60000);
8
SELECT * FROM TRADE;
9
CREATE TABLE CUSTOMER (
C_CODE VARCHAR2(4) CONSTRAINT PK_CUSTOMER PRIMARY KEY,
C_NAME VARCHAR2(30),
C_CEO VARCHAR2(12),
C_ADDR VARCHAR2(100),
C_PHONE VARCHAR2(13)
);
10
DESC CUSTOMER;
11
INSERT INTO CUSTOMER VALUES('101', '늘푸른회사', '김수종', '경기도 안산시', '010-1234-5678');
INSERT INTO CUSTOMER VALUES('102', '사랑과바다', '박나리', '경기도 평택시', '010-1122-3344');
INSERT INTO CUSTOMER VALUES('103', '대한회사', '이민수', '서울시 구로구', '010-3785-8809');
INSERT INTO CUSTOMER VALUES('104', '하얀기판', '허진수', '경상북도 포항시', '010-8569-3468');
INSERT INTO CUSTOMER VALUES('105', '한마음한뜻', '하민우', '인천시 남동구', '010-9455-6033');
12
SELECT * FROM CUSTOMER;
13
CREATE TABLE STOCK (
P_CODE CHAR(3) PRIMARY KEY,
A_QTY NUMBER,
S_LASTDATE DATE
)
14
DESC STOCK;
15
INSERT INTO STOCK VALUES ('101', 50, TO_DATE('2016-04-01', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('102', 20, TO_DATE('2016-04-26', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('103', 5, TO_DATE('2016-05-20', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('201', 2, TO_DATE('2016-04-13', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('301', 0, TO_DATE('2016-06-02', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('302', 20, TO_DATE('2016-05-02', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('401', 10, TO_DATE('2016-06-15', 'YYYY-MM-DD'));
INSERT INTO STOCK VALUES ('402', 7, TO_DATE('2016-05-08', 'YYYY-MM-DD'));
16
SELECT * FROM STOCK;
17
ALTER TABLE [테이블명] ADD ([열이름] [열타입])
ALTER TABLE TEST ADD (GENDER CHAR(1));
ALTER TABLE PRODUCT ADD (REMARK CHAR(16));
18
DESC PRODUCT;
19
ALTER TABLE PRODUCT MODIFY (REMARK NUMBER);
20
DESC PRODUCT;
21
ALTER TABLE PRODUCT DROP COLUMN REMARK;
22
DESC PRODUCT;
23
RENAME PRODUCT TO PRODUCT1;
24
DESC PRODUCT;
25
DELETE FROM PRODUCT1 WHERE 1=1;
26
RENAME PRODUCT1 TO PRODUCT;
SELECT * FROM PRODUCT;
27
DROP TABLE PRODUCT;
28
DESC PRODUCT;
29
ALTER TABLE PRODUCT ADD CONSTRAINT p_p_code primary key(p_code);

ALTER TABLE STOCK ADD CONSTRAINT f_p_code foreign key (p_code)
references product(p_code);
SELECT OWNER, CONSTRAINT_NAME, TABLE_NAME FROM USER_CONSTRAINTS WHERE TABLE_NAME IN('PRODUCT', 'STOCK');
30
