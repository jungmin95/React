<<<<<<<<20200604>>>>>>>>
문제
테이블명 MODULES
MODULES_CODE(PK) MODULE_NAME
CM0001 Databases
CM0002 OperatingSystem
CM0003 Graphics

CREATE TABLE MODULES(
MODULE_CODE CHAR(6),
MODULENAME VARCHAR2(25),
CONSTRAINT PK_STUDENTS PRIMARY KEY(MODULE_CODE)
);
INSERT INTO MODULES(MODULE_CODE, MODULENAME) VALUES ('CM0001', 'Databases');
INSERT INTO MODULES(MODULE_CODE, MODULENAME) VALUES ('CM0002', 'OperatingSystem');
INSERT INTO MODULES(MODULE_CODE, MODULENAME) VALUES ('CM0003', 'Graphics');
ALTER TABLE MARKS RENAME COLUMN MODULECODE TO MODULE_CODE;
테이블명 MARK
STU_NO MODULECODE MARK
20060101 CM0001	      80
20060102 CM0002         50
20060103 CM0003         75

CREATE TABLE MARK (
STU_NO NUMBER(8),
MODULECODE VARCHAR2(15),
MARK NUMBER(2) );

INSERT INTO MARK(STU_NO, MODULECODE, MARK) VALUES (20060101, 'CM0001', 80);
INSERT INTO MARK(STU_NO, MODULECODE, MARK) VALUES (20060102, 'CM0002', 50);
INSERT INTO MARK(STU_NO, MODULECODE, MARK) VALUES (20060103, 'CM0003', 75);

문7)
->1.MODULES 테이블에 컬럼추가
INSERT INTO MODULES VALUES('CM0002', 'Middel Ware');

->2. MARK -> MARKS으로 컬럼명 변경
ALTER TABLE MARK RENAME COLUMN MARK TO MARKS

->3. MARKS 컬럼타입변경 (NUMBER2,0))?
RENAME MARK TO MARKS;
ALTER TABLE MARKS MODIFY (MARKS NUMBER(1,0));


->4. MARKS.MODULE_CODE열에 FK추가하여 MODULES과 연결관계를 완성하시오
ALTER TABLE MARKS ADD CONSTRAINT fk_module_code 
FOREIGN KEY(MODULE_CODE)
REFERENCES MODULES(MODULE_CODE);
ALTER TABLE MARKS MODIFY (MODULE_CODE CHAR(6));
->5. MARKS테이블에 새로운 로우 데이터 추가

INSERT INTO MARKS VALUES (20060105, 'CM0004', 65);

[VIEW]
Talbe과 유사하고 Table처럼 사용하지만 Table과는 달리 Data를 저장하기위한 물리적 저장공간을 필요하지않음

예) 사원번호, 사원이름, 근무지를 출력하시오
SELECT EMPNO, ENAME, LOC FROM EMP JOIN DEPT ON (EMP.DEPTNO = DEPT.DEPTNO);

CREATE VIEW V_EMP_LOC AS
SELECT EMPNO, ENAME, LOC FROM EMP JOIN DEPT ON (EMP.DEPTNO = DEPT.DEPTNO);
SELECT * FROM V_EMP_LOC;
SELECT * FROM V_EMP_LOC WHERE LOC = 'CHICAGO';
INSERT INTO V_EMP_LOC (EMPNO, ENAME) VALUES(9998, 'B');
UPDATE V_EMP_LOC SET ENAME = 'YEODB' WHERE EMPNO = 7777;
DELETE FROM V_EMP_LOC WHERE EMPNO = 7777;
SELECT * FROM EMP;

CREATE OR REPLACE VIEW V_EMP_LOC AS
SELECT EMPNO, ENAME, LOC FROM EMP LEFT OUTER JOIN DEPT ON (EMP.DEPTNO = DEPT.DEPTNO);

문1) EMP테이블로 부터 10, 20번 부서 사원들의 뷰를 만드시오.
CREATE or replace VIEW V_EMP AS
SELECT * FROM EMP WHERE DEPTNO IN(10,20);
SELECT * FROM V_EMP;

문2) 사원번호, 사원이름, 부서이름, 상급자 이름으로 구성된 뷰를 만드시오.
CREATE OR REPLACE VIEW V_EMP_MGR AS
SELECT E1.EMPNO EMPNO, E1.ENAME ENAME, D.DNAME DNAME, E2.ENAME MGR_NAME
FROM EMP E1, DEPT D, EMP E2
WHERE E1.DEPTNO = D.DEPTNO
AND E1.MGR = E2.EMPNO;
SELECT * FROM V_EMP_MGR;
문3) 학과별 평균 몸무게와 평균 키를 가지는 뷰를 만드시오.
CREATE VIEW V_STUDENT_AVG (DEPT, AVG_WEIGHT, AVG_HEIGHT) AS
SELECT STU_DEPT, ROUND(AVG(STU_HEIGHT)), ROUND(AVG(STU_WEIGHT)) FROM STUDENT GROUP BY STU_DEPT;
CREATE OR REPLACE VIEW STUDENT_AVG_BODY (DEPT, AVG_WEIGHT, AVG_HEIGHT) AS
SELECT STU_DEPT, ROUND(AVG(STU_HEIGHT)), ROUND(AVG(STU_WEIGHT)) FROM STUDENT WHERE STU_DEPT IS NOT NULL GROUP BY STU_DEPT;
SELECT * FROM STUDENT_AVG_BODY;
[view 삭제]
DROP VIEW V_EMP_MGR;
문4) 학생이름, 키, 몸무게, BMI지수를 가지는 뷰를 만드시오
BMI = 몸무게(KG) / (신장(M)*신장(M))
CREATE OR REPLACE VIEW V_BMI (STU_NAME, STU_HEIGHT, STU_WEIGHT, BMI) AS

SELECT STU_NAME, STU_HEIGHT, STU_WEIGHT, ROUND((1000*STU_HEIGHT/POWER(STU_WEIGHT,2)),1) BMI FROM STUDENT;

SELECT * FROM V_BMI;

SELECT STU_NAME, STU_HEIGHT, STU_WEIGHT, (STU_WEIGHT/(STU_HEIGHT*STU_HEIGHT)) BMI FROM STUDENT;
문5) 사원 번호, 이름, 부서명, 급여, 커미션, 전체수입(SAL+COMM)을 가지는 뷰를 만드시오
SELECT * FROM EMP;
CREATE OR REPLACE VIEW V_EMP_ALL (EMPNO, ENAME, DNAME, SAL, COMM, 급여) AS
SELECT E1.EMPNO EMPNO, E1.ENAME ENAME, D.DNAME DNAME, E1.SAL SAL, NVL(E1.COMM, 0) COMM, E1.SAL + NVL(E1.COMM, 0) AS 급여
FROM EMP E1, DEPT D WHERE E1.DEPTNO = D.DEPTNO;
SELECT * FROM V_EMP_ALL;

CREATE OR REPLACE VIEW V_INCOME (EMPNO, ENAME, DNAME, SAL, COMM, INCOME) AS
SELECT EMPNO, ENAME, DNAME, SAL, COMM, SAL + NVL(COMM, 0) INCOME
FROM EMP NATURAL JOIN DEPT;

[TOP-N]
SELECT ROWNUM, STU_HEIGHT
FROM (SELECT STU_HEIGHT FROM STUDENT WHERE STU_HEIGHT IS NOT NULL ORDER BY 1 DESC)
WHERE ROWNUM <= 3

문 6) 수입이 가장 많은상위 3명의 직원 번호, 수입(SAL+COMM)을 출력하시오
SELECT ROWNUM, EMPNO, INCOME FROM
(SELECT EMPNO, SAL + NVL(COMM, 0) INCOME FROM EMP ORDER BY INCOME DESC)
WHERE ROWNUM <= 3;


문7) 부서별 평균 급여가 가장 작은 부서 2개의 부서명, 평균급여를 출력하시오
SELECT ROWNUM, DNAME, AVG(SAL) FROM
SELECT ROWNUM, DNAME, INCOME FROM
(SELECT DNAME, ROUND(AVG(SAL)) INCOME FROM EMP NATURAL JOIN DEPT GROUP BY DEPTNO, DNAME HAVING AVG(SAL) IS NOT NULL ORDER BY 1)
WHERE ROWNUM <= 2;


문8) BMI크기가 상위 5명의 이름, 학번, BMI지수를 출력하시오
SELECT ROWNUM, STU_NO, STU_NAME, BMI FROM
(SELECT STU_NO, STU_NAME, ROUND((1000*STU_HEIGHT/POWER(STU_WEIGHT,2)),1) BMI FROM STUDENT WHERE STU_HEIGHT IS NOT NULL ORDER BY BMI DESC)
WHERE ROWNUM <= 5;
SELECT * 
FROM (SELECT STU_NAME, STU_NO, BMI FROM STUDENT NATURAL JOIN V_BMI ORDER BY 3 DESC) WHERE ROWNUM <6;

[INDESC]
CREATE INDEX I_ENAME ON EMP(ENAME);

SELECT * FROM EMP;

DROP INDEX I_ENAME;

[SEQUENCE]
CREATE SEQUENCE seq_num
INCREMENT BY 1
START WITH 1
MAXVALUE 100;

CREATE TABLE SEQ_TABLE (SEQ_NO, EMPNO, ENAME) AS SELECT SEQ_NUM.NEXTVAL, EMPNO, ENAME FROM EMP;

SELECT SEQ_NUM.NEXTVAL FROM DUAL;

문9) 초기값1, 증감값 2, 최대값 20, CYCLE이 가능한 시퀀스를 만드시오
CREATE SEQUENCE seq_test
INCREMENT BY 2
START WITH 1
MAXVALUE 20;
SELECT SEQ_TEST.NEXTVAL FROM DUAL;

CREATE SEQUENCE seq_num2
INCREMENT BY 2
START WITH 1
MAXVALUE 20
CYCLE
NOCACHE;

INSERT INTO FORE_STUDENT
VALUES (seq_num2.NEXTVAL, 'YEO', 'DONGBIN')